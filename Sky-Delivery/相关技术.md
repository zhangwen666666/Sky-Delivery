# Swagger

## 介绍

* 使用Swagger，你只需要按照他的规范去定义接口以及接口相关的信息，就可以做到**生成接口文档，以及在线接口调试页面。**
* 官网：http://swagger.io/
* Knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案。

```xml
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-spring-boot-starter</artifactId>
    <version>3.0.2</version>
</dependency>
```

## 使用方式

1. 导入Knife4j的maven坐标

2. 在配置类中加入knife4j相关配置

3. 设置静态资源映射，否则接口文档页面无法访问

   * 配置静态资源方法一：创建Java配置类实现WebMvcConfigurer接口

     ```java
     @Configuration
     public class WebConfig implements WebMvcConfigurer {
     
         /**
          * 设置静态资源映射
          * @param registry
          */
         protected void addResourceHandlers(ResourceHandlerRegistry registry) {
             log.info("开始设置静态资源映射");
             registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
             registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
         }
     }
     ```

   * 配置静态资源方法二：在配置文件中设置静态资源映射

     ```properties
     spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/
     ```

   * 如果没有配置静态资源映射，Spring Boot会自动从以下classpath路径下查找静态资源：

     ```
     classpath:/META-INF/resources/
     classpath:/resources/
     classpath:/static/
     classpath:/public/
     ```

4. 在WebMvcConfiguration配置类中添加配置项：

   ```java
   /**
    * 通过knife4j生成接口文档
    * @return
    */
   @Bean
   public Docket docket() {
       log.info("准备生成接口文档");
       ApiInfo apiInfo = new ApiInfoBuilder()
               .title("苍穹外卖项目接口文档") //标题
               .version("2.0") // 版本
               .description("苍穹外卖项目接口文档") //描述信息
               .build();
       Docket docket = new Docket(DocumentationType.SWAGGER_2) // Swagger版本
               .apiInfo(apiInfo)
               .select()
   	        // 指定生成接口需要扫描的包（以及子包）
               .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
               .paths(PathSelectors.any())
               .build();
       return docket;
   }
   ```

## 常用注解

* 通过注解可以控制生成的接口文档，使接口文档拥有更好的可读性，常用注解如下：

  | 注解                        | 说明                                                   |
  | --------------------------- | ------------------------------------------------------ |
  | @Api(tags = "")             | 用在类上，例如Controller，表示对类的说明               |
  | @ApiModel(description = "") | 用在类上，例如entity、DTO、VO                          |
  | @ApiModelProperty("")       | 用在属性上，描述属性信息                               |
  | @ApiOperation("")           | 用在方法上，例如Controller的方法，说明方法的用途、作用 |






# MD5加密算法

## 简介

* MD5（Message Digest Algorithm 5）是一种广泛使用的密码散列函数，由MIT的计算机科学家Ronald Rivest设计，并于1992年发布。MD5的主要用途是生成一个128位（16字节）的哈希值**（通常表示为32位的十六进制数）**，用于确保数据完整性。尽管MD5在早期被广泛应用于各种安全场景，但由于其存在一些已知的安全漏洞，目前不再推荐用于需要高强度安全性的场合。

## 工作原理

MD5的基本思想是将任意长度的消息压缩成一个固定长度（128位）的哈希值。具体过程可以分为以下几个步骤：

1. **填充消息**：首先对输入消息进行填充，使得其长度对512取模后余数为448（即总长度为512*n + 448）。填充规则是在消息后面添加一个1位和若干个0位，直到满足条件为止。最后再附加一个64位的长度字段，表示原始消息的长度（以比特为单位）。
2. **初始化缓冲区**：MD5使用四个32位寄存器（A, B, C, D），它们的初始值分别为：
   * A: `0x67452301`
   * B: `0xEFCDAB89`
   * C: `0x98BADCFE`
   * D: `0x10325476`
3. **分块处理**：将填充后的消息分成512位的块，每个块进一步分成16个32位子块。对于每个512位块，依次执行以下操作：
   - 将当前块的16个32位子块扩展为64个32位子块。
   - 使用非线性函数（F、G、H、I）和循环移位等操作更新缓冲区的四个寄存器（A, B, C, D）。
4. 输出结果：经过所有块的处理后，缓冲区中的四个寄存器（A, B, C, D）按顺序拼接起来形成最终的128位哈希值。

## MD5的特点

- **确定性**：相同的输入总是产生相同的输出。
- **快速计算**：MD5的设计使其能够快速计算出哈希值。
- **抗碰撞性弱**：由于存在已知的碰撞攻击方法，MD5无法有效防止不同的输入产生相同的哈希值。
- **不可逆性**：从哈希值反推出原始输入几乎是不可能的（除非使用暴力破解或彩虹表）。

## MD5的应用场景

尽管MD5存在安全问题，但在某些特定场景下仍然有用：

1. **校验文件完整性**：通过比较下载文件的MD5哈希值与官方提供的哈希值，可以检测文件是否在传输过程中损坏或被篡改。
2. **数字签名**：虽然不建议单独使用MD5进行数字签名，但有时会与其他更安全的算法结合使用。
3. **存储密码**：早期曾用于存储用户密码的哈希值，但现在不推荐这样做，因为MD5容易受到彩虹表攻击和暴力破解。

## 安全性问题

MD5的安全性问题主要体现在以下几个方面：

- **碰撞攻击**：研究人员已经找到了构造不同消息具有相同MD5哈希值的方法。这意味着MD5不能保证唯一性，容易被利用进行伪造攻击。
- **预映射攻击**：通过预先计算大量可能的输入及其对应的哈希值（如彩虹表），可以在较短时间内找到给定哈希值的原像。
- **长度扩展攻击**：在不知道原始消息的情况下，可以通过已知的哈希值和消息长度来计算附加内容后的哈希值

## 使用

```java
import org.springframework.util.DigestUtils;

String password = "123456";
// 方法传入一个byte类型数组，返回一个字符串。
password = DigestUtils.md5DigestAsHex(password.getBytes());
```

